import os
import shutil
from typing import Optional

from .metadata import MetadataDB
from .index import VectorIndex

from api_models import AddDocumentChunk, RootQueryResult, DocumentInfoResponse, DocumentChunk, DocumentInfo


_DATA_ROOT = "/vector_index"
_ROOT_INDEX_NAME = "root_index"
_ROOT_METADATA_NAME = "root_medatata"
_SUB_INDEX_PATH = "/vector_index/sub_index"
_UPLOADED_FILES_PATH = "/uploaded_files"

_vector_db_config = {
    "data_root": _DATA_ROOT,
    "root_index_name": _ROOT_INDEX_NAME,
    "sub_index_path": _SUB_INDEX_PATH 
}

_metadata_db_config = {
    "data_root": _DATA_ROOT,
    "root_db_name": _ROOT_METADATA_NAME,
    "sub_index_path": _SUB_INDEX_PATH
}

class DataStore:
    """
    Represents a data store that manages the storage and retrieval of
    document embeddings and metadata. It is composed of a vector index
    that stores the embeddings and a metadata database that stores the
    metadata for the documents. 
    The data is organized as follows:
    - The root index stores all the embeddings of the documents. The embedding
        of a whole document is generated by embedding the document summary.
    - The root metadata db stores the metadata for the documents in the root
        index. The metadata includes the faiss ID, document UUID, hash, 
        filename, and summary. 
    
    Additionally, for each document:
    - A sub-index stores the embeddings of the document chunks. The embedding
        of a document chunk is generated by embedding the text of the chunk.
    - A sub-metadata db stores the metadata for the document chunks. 
        The metadata includes the faiss ID, document UUID, page number, and 
        text.
    
    Using the combination of metadata and vector index is therefore possible
    to retrieve either the embedding or the metadata of a document or a
    document chunk.
    """
    def __init__(self, embedding_length: int) -> None:
        """
        Initializes the DataStore object with the given parameters.

        Args:
        - embedding_length (int): The length of the embeddings to be stored.
        """
        if not os.path.isdir(_DATA_ROOT):
            raise RuntimeError(f"Data root at {_DATA_ROOT} does not exist!")
        if not os.path.isdir(_UPLOADED_FILES_PATH):
            raise RuntimeError(
                f"Uploaded files path at {_UPLOADED_FILES_PATH} does not exist!")

        if not os.path.isdir(_SUB_INDEX_PATH):
            os.makedirs(_SUB_INDEX_PATH)
        self.embedding_length = embedding_length
        self.vector_index = VectorIndex(embedding_length, **_vector_db_config)
        self.metadata_db = MetadataDB(**_metadata_db_config) 

    def has_document(
        self,
        document_hash_str: str
    ) -> bool:
        """
        Checks if the given document hash is in the datastore.
        
        Args:
        - document_hash_str (str): The hash of the document to check.
        
        Returns:
        - bool: True if the document is in the datastore, False otherwise.
        """
        return self.metadata_db.has_document(document_hash_str)
    
    def has_document_uuid(
        self,
        document_uuid: str
    ) -> bool:
        """
        Checks if the given document UUID is in the datastore.

        Args:
        - document_uuid (str): The UUID of the document to check.

        Returns:
        - bool: True if the document is in the datastore, False otherwise.
        """
        return self.metadata_db.has_document_uuid(document_uuid)

    def add_document(
        self,
        document_uuid: str,
        document_hash_str: str,
        document_filename: str,
        document_embedding: list[float],
        document_summary: str,
        document_chunks: list[AddDocumentChunk]
    ) -> None:
        """
        Adds the given document to the datastore. The document is added to the
        root index and the sub-indexes. The metadata for the document is also
        added to the metadata database.

        Args:
        - document_uuid (str): The UUID of the document.
        - document_hash_str (str): The hash of the document.
        - document_filename (str): The filename of the document.
        - document_embedding (list[float]): The embedding of the document.
        - document_summary (str): The summary of the document.
        - document_chunks (list[AddDocumentChunk]): The chunks of the document.
        """
        if self.metadata_db.has_document(document_hash_str):
            raise ValueError("Document already exists in the datastore!")
        
        root_index_id = self.vector_index.add_to_root(document_embedding)
        self.metadata_db.add_root_metadata(
            root_index_id,
            document_uuid,
            document_hash_str,
            document_filename,
            document_summary
        )

        chunks_embeddings = [
            chunk.embedding for chunk in document_chunks
        ]
        
        sub_index_ids = self.vector_index.add(
            document_uuid,
            chunks_embeddings
        )

        chunks_text = [
            chunk.text for chunk in document_chunks
        ]
        chunks_page = [
            chunk.page_number for chunk in document_chunks
        ]

        self.metadata_db.add(
            document_uuid,
            sub_index_ids,
            chunks_page,
            chunks_text
        )   
    
    def delete_document(
        self,
        document_uuid: str
    ) -> str:
        """
        Deletes the document with the given UUID from the datastore. The 
        document is removed from the root index and the sub-indexes. 
        The metadata for the document is also removed from the metadata
        database.
        
        Args:
        - document_uuid (str): The UUID of the document to delete.
        
        Returns:
        - str: The filename of the deleted document.
        """
        faiss_id, document_filename = self.metadata_db.remove_from_root(document_uuid)
        self.vector_index.remove_from_root(faiss_id)
        self.metadata_db.remove(document_uuid)
        self.vector_index.remove(document_uuid)

        return document_filename
        

    def query_root(
        self,
        query_embedding: list[float]
    ) -> list[RootQueryResult]:
        """
        Queries the root index with the given embedding and returns the
        top-k nearest neighbors.

        Args:
        - query_embedding (list[float]): The embedding to query the index with.

        Returns:
        - list[RootQueryResult]: The top-k nearest neighbors of the query.
        """
        root_ids = self.vector_index.query_root(query_embedding)
        query_result = self.metadata_db.query_root(root_ids)
        result = [
            RootQueryResult(uuid=row[0], summary=row[1])
            for row in query_result
        ]
        return result
    
    def query_documents(
        self,
        document_uuids: str | list[str],
        query_embedding: list[float]
    ) -> list[DocumentChunk]:
        """
        Queries the sub-indexes with the given document UUIDs and returns the
        top-k nearest neighbors for each document.

        Args:
        - document_uuids (str | list[str]): The UUID or list of UUIDs of the
            documents to query.
        - query_embedding (list[float]): The embedding to query the index with.

        Returns:
        - list[DocumentChunk]: The top-k nearest neighbors of the query for each
            document.
        """
        if isinstance(document_uuids, str):
            document_uuids = [document_uuids]
        
        result = []
        for document_uuid in document_uuids:
            faiss_ids = self.vector_index.query(document_uuid, query_embedding)
            query_result = self.metadata_db.query(document_uuid, faiss_ids)
            result.extend([
                DocumentChunk(text=row[1], page_number=row[0])
                for row in query_result
            ])
            
        return result
    
    def get_document_info(self, document_uuid: Optional[str]) -> DocumentInfo:
        """
        Gets the metadata for the document with the given UUID. If no UUID is
        provided, gets the metadata for all documents in the datastore.

        Args:
        - document_uuid (str): The UUID of the document to get the metadata for.
            If no UUID is provided, gets the metadata for all documents.

        Returns:
        - DocumentInfoResponse: The metadata for the document or all documents.
        """
        document_info = (
            self.metadata_db.get_document_info(document_uuid) 
            if document_uuid 
            else self.metadata_db.get_documents_info()
        )
        return DocumentInfoResponse(
            document_count=len(document_info),
            documents_info=document_info
        )
        
    def close(self):
        self.vector_index.close()
        self.metadata_db.close()

    def clear(self):
        self.vector_index.clear_root()
        self.metadata_db.clear_root()

        shutil.rmtree(_SUB_INDEX_PATH)
        os.makedirs(_SUB_INDEX_PATH)
    